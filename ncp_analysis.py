#!/usr/bin/env python
"""
ncp_analysis.py

Calculates NCP-NCP stacking parameters and generates a PyMOL visualization
script based on a detailed configuration file.

This script reads a PDB file and a configuration file (generated by
ncp_identification.py) that defines the chains and residues belonging to each
Nucleosome Core Particle (NCP). It then calculates a local coordinate system
(basis) for each NCP, consisting of a center of mass, a symmetry axis, and a
plane normal.

Using these coordinate systems, it computes a set of stacking parameters
(distance, rise, shift, tilt, etc.) for adjacent NCP pairs. The results are
saved to a text file.

Finally, it generates a PyMOL script (.pml) to visualize the NCPs, their
coordinate axes, the calculated parameters, and key structural features like
the dyad axis base pairs. It also saves a cleaned PDB file containing only the
atoms relevant to the identified NCPs.

Usage:
    python ncp_analysis.py <PDB_FILE> -c <CONFIG_FILE> [-o <OUTPUT_PREFIX>]

Example:
    python ncp_analysis.py 1zbb.pdb -c 1zbb_config.txt -o 1zbb_analysis
"""

import argparse
import os
import numpy as np
from Bio.PDB import PDBParser, PDBIO, Select
from collections import defaultdict
import warnings
from Bio.PDB.PDBExceptions import PDBConstructionWarning

# Import shared constants
from ncp_constants import HISTONE_CORE_RANGES

# --- Class for PDB cleaning ---
class NCPSelect(Select):
    """
    A Bio.PDB.Select class to filter atoms for the output PDB file.

    This class is used to select only the atoms that are part of the identified
    NCPs (both histone core regions and DNA segments) as defined in the
    configuration file. This creates a "cleaned" PDB file showing only the
    structures of interest.
    """
    def __init__(self, ncp_configs, histone_map, core_ranges):
        """
        Initializes the selection object.

        Args:
            ncp_configs (list): A list of dictionaries, where each dictionary
                contains the configuration for one NCP.
            histone_map (dict): A mapping of chain IDs to histone types (e.g., 'H3').
            core_ranges (dict): A dictionary defining the start and end residue
                IDs for the structured core of each histone type.
        """
        self.residues_to_keep = set()
        for ncp_def in ncp_configs:
            for chain_id in ncp_def['histone_chains']:
                h_type = histone_map.get(chain_id)
                if h_type and h_type in core_ranges:
                    start, end = core_ranges[h_type]
                    for res_id in range(start, end + 1):
                        self.residues_to_keep.add((chain_id, res_id))
            for chain_id, start, end in ncp_def['dna_segments']:
                for res_id in range(int(start), int(end) + 1):
                    self.residues_to_keep.add((chain_id, res_id))

    def accept_residue(self, residue):
        """
        Determines whether to accept a residue for inclusion in the output.

        This method is called by the PDBIO object for each residue in the
        structure.

        Args:
            residue (Bio.PDB.Residue): The residue to check.

        Returns:
            bool: True if the residue should be kept, False otherwise.
        """
        return (residue.get_parent().id, residue.id[1]) in self.residues_to_keep

# --- Configuration Parsing ---
def parse_config_file(config_file):
    """
    Parses the NCP configuration file generated by ncp_identification.py.

    Args:
        config_file (str): The path to the configuration file.

    Returns:
        list: A list of dictionaries, where each dictionary holds the parsed
              configuration for a single NCP.
    """
    ncps_config = []
    with open(config_file, 'r') as f:
        current_ncp = None
        for line in f:
            line = line.strip()
            if not line or line.startswith('#') or ':' not in line: continue
            key, value = line.split(':', 1)
            key, value = key.strip(), value.strip()
            if key == 'NCP':
                if current_ncp: ncps_config.append(current_ncp)
                current_ncp = {'id': int(value), 'histone_chains': [], 'dna_segments': [], 'histone_map': {},
                               'central_bp': [], 'plane_bp_neg': [], 'plane_bp_pos': []}
            elif key == 'HISTONE_CHAINS': current_ncp['histone_chains'] = value.split()
            elif key == 'HISTONE_MAP': current_ncp['histone_map'] = dict(p.split(':') for p in value.split())
            elif key == 'CENTRAL_BP': current_ncp['central_bp'] = [(p.split(':')[0], int(p.split(':')[1])) for p in value.split()]
            elif key == 'PLANE_BP_NEG': current_ncp['plane_bp_neg'] = [(p.split(':')[0], int(p.split(':')[1])) for p in value.split()]
            elif key == 'PLANE_BP_POS': current_ncp['plane_bp_pos'] = [(p.split(':')[0], int(p.split(':')[1])) for p in value.split()]
            elif key == 'DNA_SEGMENT': current_ncp['dna_segments'].append(tuple(value.split()))
    if current_ncp: ncps_config.append(current_ncp)
    return ncps_config

# --- Geometric Calculations ---
def get_center_of_mass(atom_list):
    """
    Calculates the center of mass for a list of Bio.PDB.Atom objects.

    Args:
        atom_list (list): A list of Bio.PDB.Atom objects.

    Returns:
        numpy.ndarray or None: A 3D vector for the center of mass, or None if
                               the list is empty.
    """
    if not atom_list: return None
    coords = [atom.get_coord() for atom in atom_list]
    return np.mean(coords, axis=0)

def calculate_ncp_basis(ncp_def, all_chains_map, histone_map):
    """
    Calculates the local coordinate system (basis) for a single NCP.

    The basis consists of:
    1.  com: The center of mass of the globular histone core.
    2.  axis: The symmetry (dyad) axis.
    3.  normal: The normal vector to the NCP's flat plane.

    Args:
        ncp_def (dict): The configuration dictionary for one NCP.
        all_chains_map (dict): A dictionary mapping chain IDs to Bio.PDB.Chain objects.
        histone_map (dict): A dictionary mapping chain IDs to histone types.

    Returns:
        dict or None: A dictionary containing the 'com', 'axis', 'normal', and
                      'dyad_com' vectors, or None if the basis cannot be calculated.
    """
    try:
        histone_chains = [all_chains_map[cid] for cid in ncp_def['histone_chains']]
        central_bp_residues = [all_chains_map[bp[0]][bp[1]] for bp in ncp_def['central_bp']]
        plane_bp_neg_residues = [all_chains_map[bp[0]][bp[1]] for bp in ncp_def['plane_bp_neg']]
        plane_bp_pos_residues = [all_chains_map[bp[0]][bp[1]] for bp in ncp_def['plane_bp_pos']]
        dna_segments = ncp_def['dna_segments']
        dna_residues = [res for seg in dna_segments for res in all_chains_map.get(seg[0], []) if int(seg[1]) <= res.id[1] <= int(seg[2])]
    except KeyError as e:
        print(f"DIAGNOSTIC: Skipping NCP {ncp_def['id']}. Reason: A chain or residue from config not in PDB. Missing key: {e}")
        return None

    gho_atoms = [a for c in histone_chains for r in c if histone_map.get(c.id) and HISTONE_CORE_RANGES[histone_map[c.id]][0] <= r.id[1] <= HISTONE_CORE_RANGES[histone_map[c.id]][1] for a in r if a.element != 'H']
    if not gho_atoms:
        print(f"DIAGNOSTIC: Skipping NCP {ncp_def['id']}. No histone core atoms.")
        return None
    gho_com = get_center_of_mass(gho_atoms)

    central_dna_com = get_center_of_mass([a for r in central_bp_residues for a in r if a.element != 'H'])
    if central_dna_com is None:
        print(f"DIAGNOSTIC: Skipping NCP {ncp_def['id']}. No central BP COM.")
        return None

    # Calculate both approaches for dyad axis
    h3_chains = [c for c in histone_chains if histone_map.get(c.id) == 'H3']
    h3_coms = [get_center_of_mass([a for a in c.get_atoms()]) for c in h3_chains]
    v_h3_h3 = h3_coms[0] - h3_coms[1]

    dna_coords = np.array([get_center_of_mass([a for a in res.get_atoms() if a.element != 'H']) for res in dna_residues])
    _, _, vh_dna = np.linalg.svd(dna_coords - np.mean(dna_coords, axis=0))
    v_superhelix = vh_dna[2,:]

    # Cross product dyad axis
    symmetry_axis = np.cross(v_h3_h3, v_superhelix)
    symmetry_axis /= np.linalg.norm(symmetry_axis)

    # Normalize to point toward central dyad BP
    reference_direction = central_dna_com - gho_com
    if np.dot(symmetry_axis, reference_direction) < 0:
        symmetry_axis *= -1

    # Filter the DNA residues to get only the central 129 base pairs for plane definition
    bp1_chain, bp1_resid = ncp_def['central_bp'][0]
    bp2_chain, bp2_resid = ncp_def['central_bp'][1]

    # Define the residue ID ranges for the 129bp segment on each strand
    range1_start, range1_end = bp1_resid - 64, bp1_resid + 64
    range2_start, range2_end = bp2_resid - 64, bp2_resid + 64

    central_129_residues = []
    for res in dna_residues:
        res_chain = res.get_parent().id
        res_id = res.id[1]
        # Check if the residue falls within the 129bp range on either strand
        if (res_chain == bp1_chain and range1_start <= res_id <= range1_end) or \
           (res_chain == bp2_chain and range2_start <= res_id <= range2_end):
            central_129_residues.append(res)

    plane_defining_atoms = [res['P'] for res in central_129_residues if 'P' in res]
    if len(plane_defining_atoms) < 3:
        print(f"DIAGNOSTIC: Skipping NCP {ncp_def['id']}. Not enough phosphate atoms in central 129bp to define plane.")
        return None

    plane_coords = [atom.get_coord() for atom in plane_defining_atoms]
    centroid = np.mean(plane_coords, axis=0)
    _, _, vh_plane = np.linalg.svd(plane_coords - centroid)
    plane_normal = vh_plane[2, :]
    plane_normal /= np.linalg.norm(plane_normal)

    # --- New Normalization Logic ---
    # Use the ordered BPs to determine the DNA writhe direction
    p_neg = get_center_of_mass([a for r in plane_bp_neg_residues for a in r if a.element != 'H'])
    p_pos = get_center_of_mass([a for r in plane_bp_pos_residues for a in r if a.element != 'H'])

    if p_neg is None or p_pos is None or central_dna_com is None:
        print(f"DIAGNOSTIC: Skipping NCP {ncp_def['id']}. Could not find COM for all plane-defining BPs.")
        return None

    # Define the superhelix vector based on the DNA path
    v1 = central_dna_com - p_neg
    v2 = p_pos - central_dna_com
    superhelix_vector = np.cross(v1, v2)

    # Normalize the plane_normal to point in the same direction as the superhelix vector
    if np.dot(plane_normal, superhelix_vector) < 0:
        plane_normal *= -1

    return {"com": gho_com, "axis": symmetry_axis, "normal": plane_normal, "dyad_com": central_dna_com}


def calculate_stacking_parameters(basis1, basis2):
    """
    Calculates the geometric parameters describing the stacking of two NCPs.

    Args:
        basis1 (dict): The basis dictionary for the first NCP.
        basis2 (dict): The basis dictionary for the second NCP.

    Returns:
        dict: A dictionary of stacking parameters, including 'Distance', 'Rise',
              'Shift', 'Shift Orientation', 'Symmetry Axes Orientation', 'Tilt',
              and 'Tilt Direction'.
    """
    c1, ax1, n1 = basis1["com"], basis1["axis"], basis1["normal"]
    c2, ax2, n2 = basis2["com"], basis2["axis"], basis2["normal"]
    c1_c2_vec = c2 - c1
    params = {}
    params["Distance"] = np.linalg.norm(c1_c2_vec)
    params["Rise"] = np.dot(c1_c2_vec, n1)
    proj_c2_on_plane1 = c2 - params["Rise"] * n1
    shift_vec = proj_c2_on_plane1 - c1
    params["Shift"] = np.linalg.norm(shift_vec)
    ref_vec = ax1 - np.dot(ax1, n1) * n1
    if np.linalg.norm(ref_vec) < 1e-6: ref_vec = np.cross(ax1, n1)
    ref_vec /= np.linalg.norm(ref_vec)
    if params["Shift"] > 1e-6:
        unit_shift_vec = shift_vec / params["Shift"]
        cos_phi = np.clip(np.dot(unit_shift_vec, ref_vec), -1.0, 1.0)
        angle_phi = np.rad2deg(np.arccos(cos_phi))
        sign_phi = np.sign(np.dot(np.cross(ref_vec, unit_shift_vec), n1))
        params["Shift Orientation"] = angle_phi * sign_phi
    else: params["Shift Orientation"] = 0.0
    proj_ax2_on_plane1 = ax2 - np.dot(ax2, n1) * n1
    proj_ax2_norm = np.linalg.norm(proj_ax2_on_plane1)
    if proj_ax2_norm > 1e-6:
        unit_proj_ax2 = proj_ax2_on_plane1 / proj_ax2_norm
        cos_delta = np.clip(np.dot(unit_proj_ax2, ref_vec), -1.0, 1.0)
        angle_delta = np.rad2deg(np.arccos(cos_delta))
        sign_delta = np.sign(np.dot(np.cross(ref_vec, unit_proj_ax2), n1))
        params["Symmetry Axes Orientation"] = angle_delta * sign_delta
    else: params["Symmetry Axes Orientation"] = 0.0
    cos_tilt = np.clip(np.dot(n1, n2), -1.0, 1.0)
    angle_deg = np.rad2deg(np.arccos(cos_tilt))
    params["Tilt"] = min(angle_deg, 180 - angle_deg)
    proj_n2_on_plane1 = n2 - np.dot(n2, n1) * n1
    proj_n2_norm = np.linalg.norm(proj_n2_on_plane1)
    if proj_n2_norm > 1e-6:
        # Invert the projection vector to match the paper's convention for tilt direction
        unit_proj_n2 = -proj_n2_on_plane1 / proj_n2_norm
        cos_tilt_dir = np.clip(np.dot(unit_proj_n2, ref_vec), -1.0, 1.0)
        angle_tilt_dir = np.rad2deg(np.arccos(cos_tilt_dir))
        sign_tilt_dir = np.sign(np.dot(np.cross(ref_vec, unit_proj_n2), n1))
        params["Tilt Direction"] = angle_tilt_dir * sign_tilt_dir
    else: params["Tilt Direction"] = 0.0
    return params

def generate_pymol_script(output_prefix, ncp_configs, ncp_bases, all_params, histone_map):
    """
    Generates a PyMOL script (.pml) for visualizing the NCP stacking analysis.

    The script colors each NCP, draws the coordinate system vectors, displays
    the stacking parameters as labels, and highlights key features.

    Args:
        output_prefix (str): The prefix for the output .pml file.
        ncp_configs (list): The list of NCP configuration dictionaries.
        ncp_bases (list): The list of calculated NCP basis dictionaries.
        all_params (list): A list of dictionaries of stacking parameters for
                           each adjacent NCP pair.
        histone_map (dict): A mapping of chain IDs to histone types.
    """
    pml_file = f"{output_prefix}_visualization.pml"
    stack_pdb_file = f"{output_prefix}_stack.pdb"

    def format_vec(v):
        return f"[{v[0]:.3f}, {v[1]:.3f}, {v[2]:.3f}]"

    script_lines = []
    script_lines.append(f"load {stack_pdb_file}, main_obj")
    script_lines.extend(["bg_color white", "hide everything", "show cartoon", "util.cbc", "set cartoon_transparency, 0.2"])

    colors = ["palecyan", "lightorange", "lightmagenta", "palegreen"]

    for i, ncp_def in enumerate(ncp_configs):
        ncp_id = ncp_def['id']
        ncp_name = f"ncp{ncp_id}"
        color = colors[i % len(colors)]

        h_selectors = [f"(chain {c} and resi {HISTONE_CORE_RANGES[histone_map[c]][0]}-{HISTONE_CORE_RANGES[histone_map[c]][1]})" for c in ncp_def['histone_chains']]
        d_selectors = [f"(chain {seg[0]} and resi {int(seg[1])}-{int(seg[2])})" for seg in ncp_def['dna_segments']]
        script_lines.append(f"select {ncp_name}, {' or '.join(h_selectors + d_selectors)}")
        script_lines.append(f"color {color}, {ncp_name}")

        # Add H3 pair selection for each NCP
        h3_chains = [c for c in ncp_def['histone_chains'] if histone_map.get(c) == 'H3']
        if len(h3_chains) >= 2:
            h3_selector = f"(chain {h3_chains[0]} and resi {HISTONE_CORE_RANGES['H3'][0]}-{HISTONE_CORE_RANGES['H3'][1]}) or (chain {h3_chains[1]} and resi {HISTONE_CORE_RANGES['H3'][0]}-{HISTONE_CORE_RANGES['H3'][1]})"
            script_lines.append(f"select h3_pair_{ncp_id}, {h3_selector}")

        # Add dyad selection for each NCP
        if ncp_def.get('central_bp'):
            bp1, bp2 = ncp_def['central_bp']
            dyad_selector = f"(chain {bp1[0]} and resi {bp1[1]}) or (chain {bp2[0]} and resi {bp2[1]})"
            script_lines.append(f"select dyad_{ncp_id}, {dyad_selector}")
            script_lines.append(f"color magenta, dyad_{ncp_id}")
            script_lines.append(f"show sticks, dyad_{ncp_id}")


    if len(ncp_configs) > 1:
        for i in range(len(ncp_configs) - 1):
            ncp1_segs = ncp_configs[i]['dna_segments']
            ncp2_segs = ncp_configs[i+1]['dna_segments']
            for seg1_chain, seg1_start, seg1_end in ncp1_segs:
                for seg2_chain, seg2_start, seg2_end in ncp2_segs:
                    if seg1_chain == seg2_chain:
                        overlap_start = max(int(seg1_start), int(seg2_start))
                        overlap_end = min(int(seg1_end), int(seg2_end))
                        if overlap_start < overlap_end:
                            sel_name = f"overlap_{ncp_configs[i]['id']}_{ncp_configs[i+1]['id']}_{seg1_chain}"
                            script_lines.append(f"select {sel_name}, chain {seg1_chain} and resi {overlap_start}-{overlap_end}")
                            script_lines.append(f"color hotpink, {sel_name}")

    for i, ncp in enumerate(ncp_bases):
        ncp_id = ncp['id']
        com, axis, normal = ncp['com'], ncp['axis'], ncp['normal']
        color = colors[i % len(colors)]
        script_lines.append(f"pseudoatom com{ncp_id}, pos={format_vec(com)}, color={color}, sphere_scale=1.0")
        script_lines.append(f"cgo_arrow {format_vec(com)}, {format_vec(com + axis * 20)}, radius=0.3, color=red, name=axis{ncp_id}")
        script_lines.append(f"cgo_arrow {format_vec(com)}, {format_vec(com + normal * 20)}, radius=0.3, color=blue, name=normal{ncp_id}")

        if ncp.get('dyad_com') is not None:
            dyad_com = ncp['dyad_com']
            script_lines.append(f"pseudoatom dyad_label_{ncp_id}, pos={format_vec(dyad_com)}, color=magenta")
            script_lines.append(f'label dyad_label_{ncp_id}, "Dyad"')

        v_ref = np.cross(normal, axis)
        v_ref /= np.linalg.norm(v_ref)
        disk_cgo = [f"BEGIN, TRIANGLE_FAN, COLOR, {color}, ALPHA, 0.6, VERTEX, {com[0]:.3f}, {com[1]:.3f}, {com[2]:.3f}"]
        for k in range(41):
            angle = k * 9 * np.pi / 180
            pt = com + 40 * (np.cos(angle) * v_ref + np.sin(angle) * np.cross(normal, v_ref))
            disk_cgo.append(f"VERTEX, {pt[0]:.3f}, {pt[1]:.3f}, {pt[2]:.3f}")
        disk_cgo.append("END")
        script_lines.append(f"load_cgo([ { ', '.join(disk_cgo)} ], plane{ncp_id}, 1)")

    if all_params:
        for i, params in enumerate(all_params):
            ncp1, ncp2 = ncp_bases[i], ncp_bases[i+1]
            c1, c2 = ncp1['com'], ncp2['com']
            script_lines.append(f"cgo_arrow {format_vec(c1)}, {format_vec(c2)}, radius=0.3, color=black, name=dist_vec_{ncp1['id']}_{ncp2['id']}")

            line_vector = c2 - c1
            line_midpoint = (c1 + c2) / 2.0

            # Find a robust perpendicular offset vector for the labels
            if np.linalg.norm(np.cross(line_vector, [0,0,1])) > 1e-3:
                offset_dir = np.cross(line_vector, [0,0,1])
            else: # if line_vector is parallel to Z, use X-axis
                offset_dir = np.cross(line_vector, [1,0,0])
            offset_dir /= np.linalg.norm(offset_dir)

            label_base_pos = line_midpoint + offset_dir * 20

            title_name = f"label_title_{ncp1['id']}_{ncp2['id']}"
            script_lines.append(f'pseudoatom {title_name}, pos={format_vec(label_base_pos)}')
            script_lines.append(f'label {title_name}, "NCP {ncp1["id"]}-NCP {ncp2["id"]} Stack"')

            y_offset = -8
            for key, value in params.items():
                unit = " A" if key in ["Distance", "Rise", "Shift"] else " deg"
                label_text = f'"{key}: {value:.1f}{unit}"'
                label_name = f"label_{ncp1['id']}_{ncp2['id']}_{key.replace(' ','_')}"
                label_pos = label_base_pos + np.array([0, y_offset, 0])
                script_lines.append(f'pseudoatom {label_name}, pos={format_vec(label_pos)}')
                script_lines.append(f'label {label_name}, {label_text}')
                y_offset -= 6

    script_lines.extend([
        "set label_color, black, label_*", "set label_size, 16", "set label_font_id, 7",
        "hide labels, com* dyad_label_*", "group basis_vectors, com* axis* normal* plane*",
        "group dyads, dyad_*", "group h3_pairs, h3_pair_*", "group labels, label_*", "group stacking_vectors, dist_vec_*", "zoom visible"
    ])

    with open(pml_file, 'w', encoding='utf-8') as f:
        f.write("\n".join(script_lines))
    print(f"Generated PyMOL script: {pml_file}")

def main():
    """
    Main function to parse arguments and run the analysis pipeline.
    """
    parser = argparse.ArgumentParser(description="Calculate NCP stacking parameters and generate visualization.")
    parser.add_argument("pdb_file", help="Path to the input PDB file.")
    parser.add_argument("-c", "--config", required=True, help="Path to the NCP configuration file.")
    parser.add_argument("-o", "--output-prefix", default=None, help="Prefix for all output files. Defaults to the basename of PDB filename.")
    args = parser.parse_args()

    if not os.path.exists(args.pdb_file): return print(f"Error: PDB file not found at {args.pdb_file}")
    if not os.path.exists(args.config): return print(f"Error: Config file not found at {args.config}")

    pdb_id = os.path.splitext(os.path.basename(args.pdb_file))[0]
    output_prefix = args.output_prefix if args.output_prefix else pdb_id

    ncps_config = parse_config_file(args.config)
    if not ncps_config: return print("Error: No NCPs found in config file.")

    p = PDBParser()
    structure = p.get_structure(pdb_id, args.pdb_file)
    all_chains_map = {c.id: c for c in structure.get_chains()}
    histone_map = {k: v for ncp in ncps_config for k, v in ncp.get('histone_map', {}).items()}

    ncp_bases = []
    for ncp_def in ncps_config:
        print(f"Processing NCP {ncp_def['id']}...")
        basis = calculate_ncp_basis(ncp_def, all_chains_map, histone_map)
        if basis: ncp_bases.append({'id': ncp_def['id'], **basis})

    if len(ncp_bases) < 2:
        print("Analysis requires at least two valid NCPs. Aborting.")
        if len(ncp_bases) == 1:
            generate_pymol_script(output_prefix, ncps_config, ncp_bases, [], histone_map)
        return

    ncp_bases.sort(key=lambda x: x['id'])
    all_params = [calculate_stacking_parameters(ncp_bases[i], ncp_bases[i+1]) for i in range(len(ncp_bases) - 1)]

    results_file = f"{output_prefix}_results.txt"
    with open(results_file, 'w') as f:
        f.write(f"NCP Stacking Analysis Results for {pdb_id}\n")
        for i, params in enumerate(all_params):
            f.write(f"\n--- NCP {ncp_bases[i]['id']} - NCP {ncp_bases[i+1]['id']} ---\n")
            for key, value in params.items():
                unit = "A" if key in ["Distance", "Rise", "Shift"] else "deg"
                f.write(f"{key:<25}: {value:8.2f} {unit}\n")
    print(f"\nAnalysis results saved to: {results_file}")

    print("\nCreating visualization files...")
    io = PDBIO()
    io.set_structure(structure)
    stack_pdb_file = f"{output_prefix}_stack.pdb"
    io.save(stack_pdb_file, NCPSelect(ncps_config, histone_map, HISTONE_CORE_RANGES))
    print(f"Saved clustered NCP stack to {stack_pdb_file}")

    print("Generating PyMOL script...")
    generate_pymol_script(output_prefix, ncps_config, ncp_bases, all_params, histone_map)
    print("\nProcess complete.")

if __name__ == "__main__":
    main()
