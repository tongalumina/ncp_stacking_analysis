#!/usr/bin/env python
"""
ncp_analysis.py

Calculates NCP-NCP stacking parameters and generates a visualization script.
Reads a detailed configuration file generated by ncp_identification.py.
"""

import argparse
import os
import numpy as np
from Bio.PDB import PDBParser, PDBIO, Select
from collections import defaultdict
import warnings
from Bio.PDB.PDBExceptions import PDBConstructionWarning

warnings.filterwarnings("ignore", category=PDBConstructionWarning)

# --- Constants ---
HISTONE_CORE_RANGES = {
    'H2A': (21, 116),
    'H2B': (34, 121),
    'H3': (44, 135),
    'H4': (24, 102),
}

# --- Class for PDB cleaning ---
class NCPSelect(Select):
    def __init__(self, ncp_configs, histone_map, core_ranges):
        self.residues_to_keep = set()
        for ncp_def in ncp_configs:
            for chain_id in ncp_def['histone_chains']:
                h_type = histone_map.get(chain_id)
                if h_type and h_type in core_ranges:
                    start, end = core_ranges[h_type]
                    for res_id in range(start, end + 1):
                        self.residues_to_keep.add((chain_id, res_id))
            for chain_id, start, end in ncp_def['dna_segments']:
                for res_id in range(int(start), int(end) + 1):
                    self.residues_to_keep.add((chain_id, res_id))

    def accept_residue(self, residue):
        return (residue.get_parent().id, residue.id[1]) in self.residues_to_keep

# --- Configuration Parsing ---
def parse_config_file(config_file):
    ncps_config = []
    with open(config_file, 'r') as f:
        current_ncp = None
        for line in f:
            line = line.strip()
            if not line or line.startswith('#') or ':' not in line: continue
            key, value = line.split(':', 1)
            key, value = key.strip(), value.strip()
            if key == 'NCP':
                if current_ncp: ncps_config.append(current_ncp)
                current_ncp = {'id': int(value), 'histone_chains': [], 'dna_segments': [], 'histone_map': {},
                               'central_bp': [], 'plane_bp_neg': [], 'plane_bp_pos': []}
            elif key == 'HISTONE_CHAINS': current_ncp['histone_chains'] = value.split()
            elif key == 'HISTONE_MAP': current_ncp['histone_map'] = dict(p.split(':') for p in value.split())
            elif key == 'CENTRAL_BP': current_ncp['central_bp'] = [(p.split(':')[0], int(p.split(':')[1])) for p in value.split()]
            elif key == 'PLANE_BP_NEG': current_ncp['plane_bp_neg'] = [(p.split(':')[0], int(p.split(':')[1])) for p in value.split()]
            elif key == 'PLANE_BP_POS': current_ncp['plane_bp_pos'] = [(p.split(':')[0], int(p.split(':')[1])) for p in value.split()]
            elif key == 'DNA_SEGMENT': current_ncp['dna_segments'].append(tuple(value.split()))
    if current_ncp: ncps_config.append(current_ncp)
    return ncps_config

# --- Geometric Calculations ---
def get_center_of_mass(atom_list):
    if not atom_list: return None
    coords = [atom.get_coord() for atom in atom_list]
    return np.mean(coords, axis=0)

def calculate_ncp_basis(ncp_def, all_chains_map, histone_map):
    try:
        histone_chains = [all_chains_map[cid] for cid in ncp_def['histone_chains']]
        central_bp_residues = [all_chains_map[bp[0]][bp[1]] for bp in ncp_def['central_bp']]
        dna_segments = ncp_def['dna_segments']
        dna_residues = [res for seg in dna_segments for res in all_chains_map.get(seg[0], []) if int(seg[1]) <= res.id[1] <= int(seg[2])]
    except KeyError as e:
        print(f"DIAGNOSTIC: Skipping NCP {ncp_def['id']}. Reason: A chain or residue from config not in PDB. Missing key: {e}")
        return None

    gho_atoms = [a for c in histone_chains for r in c if histone_map.get(c.id) and HISTONE_CORE_RANGES[histone_map[c.id]][0] <= r.id[1] <= HISTONE_CORE_RANGES[histone_map[c.id]][1] for a in r if a.element != 'H']
    if not gho_atoms: 
        print(f"DIAGNOSTIC: Skipping NCP {ncp_def['id']}. No histone core atoms.")
        return None
    gho_com = get_center_of_mass(gho_atoms)

    central_dna_com = get_center_of_mass([a for r in central_bp_residues for a in r if a.element != 'H'])
    if central_dna_com is None: 
        print(f"DIAGNOSTIC: Skipping NCP {ncp_def['id']}. No central BP COM.")
        return None
    symmetry_axis = central_dna_com - gho_com
    symmetry_axis /= np.linalg.norm(symmetry_axis)

    plane_defining_atoms = [res['P'] for res in dna_residues if 'P' in res]
    if len(plane_defining_atoms) < 3:
        print(f"DIAGNOSTIC: Skipping NCP {ncp_def['id']}. Not enough phosphate atoms to define plane.")
        return None
    
    plane_coords = [atom.get_coord() for atom in plane_defining_atoms]
    centroid = np.mean(plane_coords, axis=0)
    _, _, vh = np.linalg.svd(plane_coords - centroid)
    plane_normal = vh[2, :]
    plane_normal /= np.linalg.norm(plane_normal)

    if np.dot(symmetry_axis, plane_normal) < 0:
        plane_normal *= -1

    return {"com": gho_com, "axis": symmetry_axis, "normal": plane_normal}

def calculate_stacking_parameters(basis1, basis2):
    c1, ax1, n1 = basis1["com"], basis1["axis"], basis1["normal"]
    c2, ax2, n2 = basis2["com"], basis2["axis"], basis2["normal"]
    c1_c2_vec = c2 - c1
    params = {}
    params["Distance"] = np.linalg.norm(c1_c2_vec)
    params["Rise"] = np.dot(c1_c2_vec, n1)
    proj_c2_on_plane1 = c2 - params["Rise"] * n1
    shift_vec = proj_c2_on_plane1 - c1
    params["Shift"] = np.linalg.norm(shift_vec)
    ref_vec = ax1 - np.dot(ax1, n1) * n1
    if np.linalg.norm(ref_vec) < 1e-6: ref_vec = np.cross(ax1, n1)
    ref_vec /= np.linalg.norm(ref_vec)
    if params["Shift"] > 1e-6:
        unit_shift_vec = shift_vec / params["Shift"]
        cos_phi = np.clip(np.dot(unit_shift_vec, ref_vec), -1.0, 1.0)
        angle_phi = np.rad2deg(np.arccos(cos_phi))
        sign_phi = np.sign(np.dot(np.cross(ref_vec, unit_shift_vec), n1))
        params["Shift Orientation"] = angle_phi * sign_phi
    else: params["Shift Orientation"] = 0.0
    proj_ax2_on_plane1 = ax2 - np.dot(ax2, n1) * n1
    proj_ax2_norm = np.linalg.norm(proj_ax2_on_plane1)
    if proj_ax2_norm > 1e-6:
        unit_proj_ax2 = proj_ax2_on_plane1 / proj_ax2_norm
        cos_delta = np.clip(np.dot(unit_proj_ax2, ref_vec), -1.0, 1.0)
        angle_delta = np.rad2deg(np.arccos(cos_delta))
        sign_delta = np.sign(np.dot(np.cross(ref_vec, unit_proj_ax2), n1))
        params["Symmetry Axes Orientation"] = angle_delta * sign_delta
    else: params["Symmetry Axes Orientation"] = 0.0
    cos_tilt = np.clip(np.dot(n1, n2), -1.0, 1.0)
    angle_deg = np.rad2deg(np.arccos(cos_tilt))
    params["Tilt"] = min(angle_deg, 180 - angle_deg)
    proj_n2_on_plane1 = n2 - np.dot(n2, n1) * n1
    proj_n2_norm = np.linalg.norm(proj_n2_on_plane1)
    if proj_n2_norm > 1e-6:
        unit_proj_n2 = proj_n2_on_plane1 / proj_n2_norm
        cos_tilt_dir = np.clip(np.dot(unit_proj_n2, ref_vec), -1.0, 1.0)
        angle_tilt_dir = np.rad2deg(np.arccos(cos_tilt_dir))
        sign_tilt_dir = np.sign(np.dot(np.cross(ref_vec, unit_proj_n2), n1))
        params["Tilt Direction"] = angle_tilt_dir * sign_tilt_dir
    else: params["Tilt Direction"] = 0.0
    return params

def generate_pymol_script(output_prefix, ncp_configs, ncp_bases, all_params, histone_map):
    pml_file = f"{output_prefix}_visualization.pml"
    stack_pdb_file = f"{output_prefix}_stack.pdb"
    
    def format_vec(v):
        return f"[{v[0]:.3f}, {v[1]:.3f}, {v[2]:.3f}]"

    script_lines = []
    script_lines.append(f"load {stack_pdb_file}, main_obj")
    script_lines.extend(["bg_color white", "hide everything", "show cartoon", "util.cbc", "set cartoon_transparency, 0.2"])

    colors = ["palecyan", "lightorange", "lightmagenta", "palegreen"]
    
    for i, ncp_def in enumerate(ncp_configs):
        ncp_name = f"ncp{ncp_def['id']}"
        color = colors[i % len(colors)]
        h_selectors = [f"(chain {c} and resi {HISTONE_CORE_RANGES[histone_map[c]][0]}-{HISTONE_CORE_RANGES[histone_map[c]][1]})" for c in ncp_def['histone_chains']]
        d_selectors = [f"(chain {seg[0]} and resi {int(seg[1])}-{int(seg[2])})" for seg in ncp_def['dna_segments']]
        script_lines.append(f"select {ncp_name}, {' or '.join(h_selectors + d_selectors)}")
        script_lines.append(f"color {color}, {ncp_name}")

    if len(ncp_configs) > 1:
        for i in range(len(ncp_configs) - 1):
            ncp1_segs = ncp_configs[i]['dna_segments']
            ncp2_segs = ncp_configs[i+1]['dna_segments']
            for seg1_chain, seg1_start, seg1_end in ncp1_segs:
                for seg2_chain, seg2_start, seg2_end in ncp2_segs:
                    if seg1_chain == seg2_chain:
                        overlap_start = max(int(seg1_start), int(seg2_start))
                        overlap_end = min(int(seg1_end), int(seg2_end))
                        if overlap_start < overlap_end:
                            sel_name = f"overlap_{i+1}_{i+2}_{seg1_chain}"
                            script_lines.append(f"select {sel_name}, chain {seg1_chain} and resi {overlap_start}-{overlap_end}")
                            script_lines.append(f"color hotpink, {sel_name}")
                            script_lines.append(f"show sticks, {sel_name}")

    for i, ncp in enumerate(ncp_bases):
        ncp_id = ncp['id']
        com, axis, normal = ncp['com'], ncp['axis'], ncp['normal']
        color = colors[i % len(colors)]
        script_lines.append(f"pseudoatom com{ncp_id}, pos={format_vec(com)}, color={color}, sphere_scale=1.0")
        script_lines.append(f"cgo_arrow {format_vec(com)}, {format_vec(com + axis * 20)}, radius=0.3, color=red, name=axis{ncp_id}")
        script_lines.append(f"cgo_arrow {format_vec(com)}, {format_vec(com + normal * 20)}, radius=0.3, color=blue, name=normal{ncp_id}")
        
        v_ref = np.cross(normal, axis)
        v_ref /= np.linalg.norm(v_ref)
        disk_cgo = [f"BEGIN, TRIANGLE_FAN, COLOR, {color}, ALPHA, 0.6, VERTEX, {com[0]:.3f}, {com[1]:.3f}, {com[2]:.3f}"]
        for k in range(41):
            angle = k * 9 * np.pi / 180
            pt = com + 40 * (np.cos(angle) * v_ref + np.sin(angle) * np.cross(normal, v_ref))
            disk_cgo.append(f"VERTEX, {pt[0]:.3f}, {pt[1]:.3f}, {pt[2]:.3f}")
        disk_cgo.append("END")
        script_lines.append(f"load_cgo([ { ', '.join(disk_cgo)} ], plane{ncp_id}, 1)")

    if all_params:
        for i, params in enumerate(all_params):
            ncp1, ncp2 = ncp_bases[i], ncp_bases[i+1]
            c1, c2 = ncp1['com'], ncp2['com']
            script_lines.append(f"cgo_arrow {format_vec(c1)}, {format_vec(c2)}, radius=0.3, color=black, name=dist_vec_{i+1}_{i+2}")
            label_pos = (c1 + c2) / 2.0
            y_offset = i * -60
            x_offset = 40
            title_name = f"label_title_{i+1}_{i+2}"
            script_lines.append(f'pseudoatom {title_name}, pos={format_vec(label_pos + np.array([x_offset, y_offset, 0]))}')
            script_lines.append(f'label {title_name}, "NCP {ncp1["id"]}-NCP {ncp2["id"]} Stack" ')
            y_offset -= 8
            for key, value in params.items():
                unit = " A" if key in ["Distance", "Rise", "Shift"] else " deg"
                label_text = f'{key}: {value:.1f}{unit}'
                label_name = f"label_{i+1}_{i+2}_{key.replace(' ','_')}"
                script_lines.append(f'pseudoatom {label_name}, pos={format_vec(label_pos + np.array([x_offset, y_offset, 0]))}')
                script_lines.append(f'label {label_name}, "{label_text}"')
                y_offset -= 6

    script_lines.extend([
        "set label_color, black, label_*", "set label_size, 16", "set label_font_id, 7",
        "hide labels, com*", "group basis_vectors, com* axis* normal* plane*",
        "group labels, label_*", "group stacking_vectors, dist_vec_*", "zoom visible"
    ])

    with open(pml_file, 'w') as f:
        f.write("\n".join(script_lines))
    print(f"Generated PyMOL script: {pml_file}")

def main():
    parser = argparse.ArgumentParser(description="Calculate NCP stacking parameters and generate visualization.")
    parser.add_argument("pdb_file", help="Path to the input PDB file.")
    parser.add_argument("-c", "--config", required=True, help="Path to the NCP configuration file.")
    parser.add_argument("-o", "--output-prefix", default=None, help="Prefix for all output files. Defaults to the basename of PDB filename.")
    args = parser.parse_args()

    if not os.path.exists(args.pdb_file): return print(f"Error: PDB file not found at {args.pdb_file}")
    if not os.path.exists(args.config): return print(f"Error: Config file not found at {args.config}")

    pdb_id = os.path.splitext(os.path.basename(args.pdb_file))[0]
    output_prefix = args.output_prefix if args.output_prefix else pdb_id

    ncps_config = parse_config_file(args.config)
    if not ncps_config: return print("Error: No NCPs found in config file.")

    p = PDBParser()
    structure = p.get_structure(pdb_id, args.pdb_file)
    all_chains_map = {c.id: c for c in structure.get_chains()}
    histone_map = {k: v for ncp in ncps_config for k, v in ncp.get('histone_map', {}).items()}

    ncp_bases = []
    for ncp_def in ncps_config:
        print(f"Processing NCP {ncp_def['id']}...")
        basis = calculate_ncp_basis(ncp_def, all_chains_map, histone_map)
        if basis: ncp_bases.append({'id': ncp_def['id'], **basis})

    if len(ncp_bases) < 2:
        print("Analysis requires at least two valid NCPs. Aborting.")
        if len(ncp_bases) == 1:
            generate_pymol_script(output_prefix, ncps_config, ncp_bases, [], histone_map)
        return

    ncp_bases.sort(key=lambda x: x['id'])
    all_params = [calculate_stacking_parameters(ncp_bases[i], ncp_bases[i+1]) for i in range(len(ncp_bases) - 1)]

    results_file = f"{output_prefix}_results.txt"
    with open(results_file, 'w') as f:
        f.write(f"NCP Stacking Analysis Results for {pdb_id}\n")
        for i, params in enumerate(all_params):
            f.write(f"\n--- NCP {ncp_bases[i]['id']} - NCP {ncp_bases[i+1]['id']} ---\n")
            for key, value in params.items():
                unit = "A" if key in ["Distance", "Rise", "Shift"] else "deg"
                f.write(f"{key:<25}: {value:8.2f} {unit}\n")
    print(f"\nAnalysis results saved to: {results_file}")

    print("\nCreating visualization files...")
    io = PDBIO()
    io.set_structure(structure)
    stack_pdb_file = f"{output_prefix}_stack.pdb"
    io.save(stack_pdb_file, NCPSelect(ncps_config, histone_map, HISTONE_CORE_RANGES))
    print(f"Saved clustered NCP stack to {stack_pdb_file}")

    print("Generating PyMOL script...")
    generate_pymol_script(output_prefix, ncps_config, ncp_bases, all_params, histone_map)
    print("\nProcess complete.")

if __name__ == "__main__":
    main()